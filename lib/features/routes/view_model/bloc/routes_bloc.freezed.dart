// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'routes_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$RoutesEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadRoutes,
    required TResult Function(Routes route) addRoute,
    required TResult Function(Routes route) updateRoute,
    required TResult Function(String id) deleteRoute,
    required TResult Function(String routeId, String driverId) assignDriver,
    required TResult Function(String routeId, List<String> storeIds)
        assignStores,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadRoutes,
    TResult? Function(Routes route)? addRoute,
    TResult? Function(Routes route)? updateRoute,
    TResult? Function(String id)? deleteRoute,
    TResult? Function(String routeId, String driverId)? assignDriver,
    TResult? Function(String routeId, List<String> storeIds)? assignStores,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadRoutes,
    TResult Function(Routes route)? addRoute,
    TResult Function(Routes route)? updateRoute,
    TResult Function(String id)? deleteRoute,
    TResult Function(String routeId, String driverId)? assignDriver,
    TResult Function(String routeId, List<String> storeIds)? assignStores,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadRoutes value) loadRoutes,
    required TResult Function(_AddRoute value) addRoute,
    required TResult Function(_UpdateRoute value) updateRoute,
    required TResult Function(_DeleteRoute value) deleteRoute,
    required TResult Function(_AssignDriver value) assignDriver,
    required TResult Function(_AssignStores value) assignStores,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadRoutes value)? loadRoutes,
    TResult? Function(_AddRoute value)? addRoute,
    TResult? Function(_UpdateRoute value)? updateRoute,
    TResult? Function(_DeleteRoute value)? deleteRoute,
    TResult? Function(_AssignDriver value)? assignDriver,
    TResult? Function(_AssignStores value)? assignStores,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadRoutes value)? loadRoutes,
    TResult Function(_AddRoute value)? addRoute,
    TResult Function(_UpdateRoute value)? updateRoute,
    TResult Function(_DeleteRoute value)? deleteRoute,
    TResult Function(_AssignDriver value)? assignDriver,
    TResult Function(_AssignStores value)? assignStores,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RoutesEventCopyWith<$Res> {
  factory $RoutesEventCopyWith(
          RoutesEvent value, $Res Function(RoutesEvent) then) =
      _$RoutesEventCopyWithImpl<$Res, RoutesEvent>;
}

/// @nodoc
class _$RoutesEventCopyWithImpl<$Res, $Val extends RoutesEvent>
    implements $RoutesEventCopyWith<$Res> {
  _$RoutesEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of RoutesEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$LoadRoutesImplCopyWith<$Res> {
  factory _$$LoadRoutesImplCopyWith(
          _$LoadRoutesImpl value, $Res Function(_$LoadRoutesImpl) then) =
      __$$LoadRoutesImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadRoutesImplCopyWithImpl<$Res>
    extends _$RoutesEventCopyWithImpl<$Res, _$LoadRoutesImpl>
    implements _$$LoadRoutesImplCopyWith<$Res> {
  __$$LoadRoutesImplCopyWithImpl(
      _$LoadRoutesImpl _value, $Res Function(_$LoadRoutesImpl) _then)
      : super(_value, _then);

  /// Create a copy of RoutesEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$LoadRoutesImpl implements _LoadRoutes {
  const _$LoadRoutesImpl();

  @override
  String toString() {
    return 'RoutesEvent.loadRoutes()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadRoutesImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadRoutes,
    required TResult Function(Routes route) addRoute,
    required TResult Function(Routes route) updateRoute,
    required TResult Function(String id) deleteRoute,
    required TResult Function(String routeId, String driverId) assignDriver,
    required TResult Function(String routeId, List<String> storeIds)
        assignStores,
  }) {
    return loadRoutes();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadRoutes,
    TResult? Function(Routes route)? addRoute,
    TResult? Function(Routes route)? updateRoute,
    TResult? Function(String id)? deleteRoute,
    TResult? Function(String routeId, String driverId)? assignDriver,
    TResult? Function(String routeId, List<String> storeIds)? assignStores,
  }) {
    return loadRoutes?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadRoutes,
    TResult Function(Routes route)? addRoute,
    TResult Function(Routes route)? updateRoute,
    TResult Function(String id)? deleteRoute,
    TResult Function(String routeId, String driverId)? assignDriver,
    TResult Function(String routeId, List<String> storeIds)? assignStores,
    required TResult orElse(),
  }) {
    if (loadRoutes != null) {
      return loadRoutes();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadRoutes value) loadRoutes,
    required TResult Function(_AddRoute value) addRoute,
    required TResult Function(_UpdateRoute value) updateRoute,
    required TResult Function(_DeleteRoute value) deleteRoute,
    required TResult Function(_AssignDriver value) assignDriver,
    required TResult Function(_AssignStores value) assignStores,
  }) {
    return loadRoutes(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadRoutes value)? loadRoutes,
    TResult? Function(_AddRoute value)? addRoute,
    TResult? Function(_UpdateRoute value)? updateRoute,
    TResult? Function(_DeleteRoute value)? deleteRoute,
    TResult? Function(_AssignDriver value)? assignDriver,
    TResult? Function(_AssignStores value)? assignStores,
  }) {
    return loadRoutes?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadRoutes value)? loadRoutes,
    TResult Function(_AddRoute value)? addRoute,
    TResult Function(_UpdateRoute value)? updateRoute,
    TResult Function(_DeleteRoute value)? deleteRoute,
    TResult Function(_AssignDriver value)? assignDriver,
    TResult Function(_AssignStores value)? assignStores,
    required TResult orElse(),
  }) {
    if (loadRoutes != null) {
      return loadRoutes(this);
    }
    return orElse();
  }
}

abstract class _LoadRoutes implements RoutesEvent {
  const factory _LoadRoutes() = _$LoadRoutesImpl;
}

/// @nodoc
abstract class _$$AddRouteImplCopyWith<$Res> {
  factory _$$AddRouteImplCopyWith(
          _$AddRouteImpl value, $Res Function(_$AddRouteImpl) then) =
      __$$AddRouteImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Routes route});
}

/// @nodoc
class __$$AddRouteImplCopyWithImpl<$Res>
    extends _$RoutesEventCopyWithImpl<$Res, _$AddRouteImpl>
    implements _$$AddRouteImplCopyWith<$Res> {
  __$$AddRouteImplCopyWithImpl(
      _$AddRouteImpl _value, $Res Function(_$AddRouteImpl) _then)
      : super(_value, _then);

  /// Create a copy of RoutesEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? route = null,
  }) {
    return _then(_$AddRouteImpl(
      null == route
          ? _value.route
          : route // ignore: cast_nullable_to_non_nullable
              as Routes,
    ));
  }
}

/// @nodoc

class _$AddRouteImpl implements _AddRoute {
  const _$AddRouteImpl(this.route);

  @override
  final Routes route;

  @override
  String toString() {
    return 'RoutesEvent.addRoute(route: $route)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddRouteImpl &&
            (identical(other.route, route) || other.route == route));
  }

  @override
  int get hashCode => Object.hash(runtimeType, route);

  /// Create a copy of RoutesEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AddRouteImplCopyWith<_$AddRouteImpl> get copyWith =>
      __$$AddRouteImplCopyWithImpl<_$AddRouteImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadRoutes,
    required TResult Function(Routes route) addRoute,
    required TResult Function(Routes route) updateRoute,
    required TResult Function(String id) deleteRoute,
    required TResult Function(String routeId, String driverId) assignDriver,
    required TResult Function(String routeId, List<String> storeIds)
        assignStores,
  }) {
    return addRoute(route);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadRoutes,
    TResult? Function(Routes route)? addRoute,
    TResult? Function(Routes route)? updateRoute,
    TResult? Function(String id)? deleteRoute,
    TResult? Function(String routeId, String driverId)? assignDriver,
    TResult? Function(String routeId, List<String> storeIds)? assignStores,
  }) {
    return addRoute?.call(route);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadRoutes,
    TResult Function(Routes route)? addRoute,
    TResult Function(Routes route)? updateRoute,
    TResult Function(String id)? deleteRoute,
    TResult Function(String routeId, String driverId)? assignDriver,
    TResult Function(String routeId, List<String> storeIds)? assignStores,
    required TResult orElse(),
  }) {
    if (addRoute != null) {
      return addRoute(route);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadRoutes value) loadRoutes,
    required TResult Function(_AddRoute value) addRoute,
    required TResult Function(_UpdateRoute value) updateRoute,
    required TResult Function(_DeleteRoute value) deleteRoute,
    required TResult Function(_AssignDriver value) assignDriver,
    required TResult Function(_AssignStores value) assignStores,
  }) {
    return addRoute(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadRoutes value)? loadRoutes,
    TResult? Function(_AddRoute value)? addRoute,
    TResult? Function(_UpdateRoute value)? updateRoute,
    TResult? Function(_DeleteRoute value)? deleteRoute,
    TResult? Function(_AssignDriver value)? assignDriver,
    TResult? Function(_AssignStores value)? assignStores,
  }) {
    return addRoute?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadRoutes value)? loadRoutes,
    TResult Function(_AddRoute value)? addRoute,
    TResult Function(_UpdateRoute value)? updateRoute,
    TResult Function(_DeleteRoute value)? deleteRoute,
    TResult Function(_AssignDriver value)? assignDriver,
    TResult Function(_AssignStores value)? assignStores,
    required TResult orElse(),
  }) {
    if (addRoute != null) {
      return addRoute(this);
    }
    return orElse();
  }
}

abstract class _AddRoute implements RoutesEvent {
  const factory _AddRoute(final Routes route) = _$AddRouteImpl;

  Routes get route;

  /// Create a copy of RoutesEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AddRouteImplCopyWith<_$AddRouteImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UpdateRouteImplCopyWith<$Res> {
  factory _$$UpdateRouteImplCopyWith(
          _$UpdateRouteImpl value, $Res Function(_$UpdateRouteImpl) then) =
      __$$UpdateRouteImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Routes route});
}

/// @nodoc
class __$$UpdateRouteImplCopyWithImpl<$Res>
    extends _$RoutesEventCopyWithImpl<$Res, _$UpdateRouteImpl>
    implements _$$UpdateRouteImplCopyWith<$Res> {
  __$$UpdateRouteImplCopyWithImpl(
      _$UpdateRouteImpl _value, $Res Function(_$UpdateRouteImpl) _then)
      : super(_value, _then);

  /// Create a copy of RoutesEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? route = null,
  }) {
    return _then(_$UpdateRouteImpl(
      null == route
          ? _value.route
          : route // ignore: cast_nullable_to_non_nullable
              as Routes,
    ));
  }
}

/// @nodoc

class _$UpdateRouteImpl implements _UpdateRoute {
  const _$UpdateRouteImpl(this.route);

  @override
  final Routes route;

  @override
  String toString() {
    return 'RoutesEvent.updateRoute(route: $route)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateRouteImpl &&
            (identical(other.route, route) || other.route == route));
  }

  @override
  int get hashCode => Object.hash(runtimeType, route);

  /// Create a copy of RoutesEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateRouteImplCopyWith<_$UpdateRouteImpl> get copyWith =>
      __$$UpdateRouteImplCopyWithImpl<_$UpdateRouteImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadRoutes,
    required TResult Function(Routes route) addRoute,
    required TResult Function(Routes route) updateRoute,
    required TResult Function(String id) deleteRoute,
    required TResult Function(String routeId, String driverId) assignDriver,
    required TResult Function(String routeId, List<String> storeIds)
        assignStores,
  }) {
    return updateRoute(route);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadRoutes,
    TResult? Function(Routes route)? addRoute,
    TResult? Function(Routes route)? updateRoute,
    TResult? Function(String id)? deleteRoute,
    TResult? Function(String routeId, String driverId)? assignDriver,
    TResult? Function(String routeId, List<String> storeIds)? assignStores,
  }) {
    return updateRoute?.call(route);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadRoutes,
    TResult Function(Routes route)? addRoute,
    TResult Function(Routes route)? updateRoute,
    TResult Function(String id)? deleteRoute,
    TResult Function(String routeId, String driverId)? assignDriver,
    TResult Function(String routeId, List<String> storeIds)? assignStores,
    required TResult orElse(),
  }) {
    if (updateRoute != null) {
      return updateRoute(route);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadRoutes value) loadRoutes,
    required TResult Function(_AddRoute value) addRoute,
    required TResult Function(_UpdateRoute value) updateRoute,
    required TResult Function(_DeleteRoute value) deleteRoute,
    required TResult Function(_AssignDriver value) assignDriver,
    required TResult Function(_AssignStores value) assignStores,
  }) {
    return updateRoute(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadRoutes value)? loadRoutes,
    TResult? Function(_AddRoute value)? addRoute,
    TResult? Function(_UpdateRoute value)? updateRoute,
    TResult? Function(_DeleteRoute value)? deleteRoute,
    TResult? Function(_AssignDriver value)? assignDriver,
    TResult? Function(_AssignStores value)? assignStores,
  }) {
    return updateRoute?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadRoutes value)? loadRoutes,
    TResult Function(_AddRoute value)? addRoute,
    TResult Function(_UpdateRoute value)? updateRoute,
    TResult Function(_DeleteRoute value)? deleteRoute,
    TResult Function(_AssignDriver value)? assignDriver,
    TResult Function(_AssignStores value)? assignStores,
    required TResult orElse(),
  }) {
    if (updateRoute != null) {
      return updateRoute(this);
    }
    return orElse();
  }
}

abstract class _UpdateRoute implements RoutesEvent {
  const factory _UpdateRoute(final Routes route) = _$UpdateRouteImpl;

  Routes get route;

  /// Create a copy of RoutesEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UpdateRouteImplCopyWith<_$UpdateRouteImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DeleteRouteImplCopyWith<$Res> {
  factory _$$DeleteRouteImplCopyWith(
          _$DeleteRouteImpl value, $Res Function(_$DeleteRouteImpl) then) =
      __$$DeleteRouteImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String id});
}

/// @nodoc
class __$$DeleteRouteImplCopyWithImpl<$Res>
    extends _$RoutesEventCopyWithImpl<$Res, _$DeleteRouteImpl>
    implements _$$DeleteRouteImplCopyWith<$Res> {
  __$$DeleteRouteImplCopyWithImpl(
      _$DeleteRouteImpl _value, $Res Function(_$DeleteRouteImpl) _then)
      : super(_value, _then);

  /// Create a copy of RoutesEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
  }) {
    return _then(_$DeleteRouteImpl(
      null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$DeleteRouteImpl implements _DeleteRoute {
  const _$DeleteRouteImpl(this.id);

  @override
  final String id;

  @override
  String toString() {
    return 'RoutesEvent.deleteRoute(id: $id)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DeleteRouteImpl &&
            (identical(other.id, id) || other.id == id));
  }

  @override
  int get hashCode => Object.hash(runtimeType, id);

  /// Create a copy of RoutesEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$DeleteRouteImplCopyWith<_$DeleteRouteImpl> get copyWith =>
      __$$DeleteRouteImplCopyWithImpl<_$DeleteRouteImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadRoutes,
    required TResult Function(Routes route) addRoute,
    required TResult Function(Routes route) updateRoute,
    required TResult Function(String id) deleteRoute,
    required TResult Function(String routeId, String driverId) assignDriver,
    required TResult Function(String routeId, List<String> storeIds)
        assignStores,
  }) {
    return deleteRoute(id);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadRoutes,
    TResult? Function(Routes route)? addRoute,
    TResult? Function(Routes route)? updateRoute,
    TResult? Function(String id)? deleteRoute,
    TResult? Function(String routeId, String driverId)? assignDriver,
    TResult? Function(String routeId, List<String> storeIds)? assignStores,
  }) {
    return deleteRoute?.call(id);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadRoutes,
    TResult Function(Routes route)? addRoute,
    TResult Function(Routes route)? updateRoute,
    TResult Function(String id)? deleteRoute,
    TResult Function(String routeId, String driverId)? assignDriver,
    TResult Function(String routeId, List<String> storeIds)? assignStores,
    required TResult orElse(),
  }) {
    if (deleteRoute != null) {
      return deleteRoute(id);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadRoutes value) loadRoutes,
    required TResult Function(_AddRoute value) addRoute,
    required TResult Function(_UpdateRoute value) updateRoute,
    required TResult Function(_DeleteRoute value) deleteRoute,
    required TResult Function(_AssignDriver value) assignDriver,
    required TResult Function(_AssignStores value) assignStores,
  }) {
    return deleteRoute(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadRoutes value)? loadRoutes,
    TResult? Function(_AddRoute value)? addRoute,
    TResult? Function(_UpdateRoute value)? updateRoute,
    TResult? Function(_DeleteRoute value)? deleteRoute,
    TResult? Function(_AssignDriver value)? assignDriver,
    TResult? Function(_AssignStores value)? assignStores,
  }) {
    return deleteRoute?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadRoutes value)? loadRoutes,
    TResult Function(_AddRoute value)? addRoute,
    TResult Function(_UpdateRoute value)? updateRoute,
    TResult Function(_DeleteRoute value)? deleteRoute,
    TResult Function(_AssignDriver value)? assignDriver,
    TResult Function(_AssignStores value)? assignStores,
    required TResult orElse(),
  }) {
    if (deleteRoute != null) {
      return deleteRoute(this);
    }
    return orElse();
  }
}

abstract class _DeleteRoute implements RoutesEvent {
  const factory _DeleteRoute(final String id) = _$DeleteRouteImpl;

  String get id;

  /// Create a copy of RoutesEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$DeleteRouteImplCopyWith<_$DeleteRouteImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AssignDriverImplCopyWith<$Res> {
  factory _$$AssignDriverImplCopyWith(
          _$AssignDriverImpl value, $Res Function(_$AssignDriverImpl) then) =
      __$$AssignDriverImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String routeId, String driverId});
}

/// @nodoc
class __$$AssignDriverImplCopyWithImpl<$Res>
    extends _$RoutesEventCopyWithImpl<$Res, _$AssignDriverImpl>
    implements _$$AssignDriverImplCopyWith<$Res> {
  __$$AssignDriverImplCopyWithImpl(
      _$AssignDriverImpl _value, $Res Function(_$AssignDriverImpl) _then)
      : super(_value, _then);

  /// Create a copy of RoutesEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? routeId = null,
    Object? driverId = null,
  }) {
    return _then(_$AssignDriverImpl(
      null == routeId
          ? _value.routeId
          : routeId // ignore: cast_nullable_to_non_nullable
              as String,
      null == driverId
          ? _value.driverId
          : driverId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AssignDriverImpl implements _AssignDriver {
  const _$AssignDriverImpl(this.routeId, this.driverId);

  @override
  final String routeId;
  @override
  final String driverId;

  @override
  String toString() {
    return 'RoutesEvent.assignDriver(routeId: $routeId, driverId: $driverId)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AssignDriverImpl &&
            (identical(other.routeId, routeId) || other.routeId == routeId) &&
            (identical(other.driverId, driverId) ||
                other.driverId == driverId));
  }

  @override
  int get hashCode => Object.hash(runtimeType, routeId, driverId);

  /// Create a copy of RoutesEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AssignDriverImplCopyWith<_$AssignDriverImpl> get copyWith =>
      __$$AssignDriverImplCopyWithImpl<_$AssignDriverImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadRoutes,
    required TResult Function(Routes route) addRoute,
    required TResult Function(Routes route) updateRoute,
    required TResult Function(String id) deleteRoute,
    required TResult Function(String routeId, String driverId) assignDriver,
    required TResult Function(String routeId, List<String> storeIds)
        assignStores,
  }) {
    return assignDriver(routeId, driverId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadRoutes,
    TResult? Function(Routes route)? addRoute,
    TResult? Function(Routes route)? updateRoute,
    TResult? Function(String id)? deleteRoute,
    TResult? Function(String routeId, String driverId)? assignDriver,
    TResult? Function(String routeId, List<String> storeIds)? assignStores,
  }) {
    return assignDriver?.call(routeId, driverId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadRoutes,
    TResult Function(Routes route)? addRoute,
    TResult Function(Routes route)? updateRoute,
    TResult Function(String id)? deleteRoute,
    TResult Function(String routeId, String driverId)? assignDriver,
    TResult Function(String routeId, List<String> storeIds)? assignStores,
    required TResult orElse(),
  }) {
    if (assignDriver != null) {
      return assignDriver(routeId, driverId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadRoutes value) loadRoutes,
    required TResult Function(_AddRoute value) addRoute,
    required TResult Function(_UpdateRoute value) updateRoute,
    required TResult Function(_DeleteRoute value) deleteRoute,
    required TResult Function(_AssignDriver value) assignDriver,
    required TResult Function(_AssignStores value) assignStores,
  }) {
    return assignDriver(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadRoutes value)? loadRoutes,
    TResult? Function(_AddRoute value)? addRoute,
    TResult? Function(_UpdateRoute value)? updateRoute,
    TResult? Function(_DeleteRoute value)? deleteRoute,
    TResult? Function(_AssignDriver value)? assignDriver,
    TResult? Function(_AssignStores value)? assignStores,
  }) {
    return assignDriver?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadRoutes value)? loadRoutes,
    TResult Function(_AddRoute value)? addRoute,
    TResult Function(_UpdateRoute value)? updateRoute,
    TResult Function(_DeleteRoute value)? deleteRoute,
    TResult Function(_AssignDriver value)? assignDriver,
    TResult Function(_AssignStores value)? assignStores,
    required TResult orElse(),
  }) {
    if (assignDriver != null) {
      return assignDriver(this);
    }
    return orElse();
  }
}

abstract class _AssignDriver implements RoutesEvent {
  const factory _AssignDriver(final String routeId, final String driverId) =
      _$AssignDriverImpl;

  String get routeId;
  String get driverId;

  /// Create a copy of RoutesEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AssignDriverImplCopyWith<_$AssignDriverImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AssignStoresImplCopyWith<$Res> {
  factory _$$AssignStoresImplCopyWith(
          _$AssignStoresImpl value, $Res Function(_$AssignStoresImpl) then) =
      __$$AssignStoresImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String routeId, List<String> storeIds});
}

/// @nodoc
class __$$AssignStoresImplCopyWithImpl<$Res>
    extends _$RoutesEventCopyWithImpl<$Res, _$AssignStoresImpl>
    implements _$$AssignStoresImplCopyWith<$Res> {
  __$$AssignStoresImplCopyWithImpl(
      _$AssignStoresImpl _value, $Res Function(_$AssignStoresImpl) _then)
      : super(_value, _then);

  /// Create a copy of RoutesEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? routeId = null,
    Object? storeIds = null,
  }) {
    return _then(_$AssignStoresImpl(
      null == routeId
          ? _value.routeId
          : routeId // ignore: cast_nullable_to_non_nullable
              as String,
      null == storeIds
          ? _value._storeIds
          : storeIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc

class _$AssignStoresImpl implements _AssignStores {
  const _$AssignStoresImpl(this.routeId, final List<String> storeIds)
      : _storeIds = storeIds;

  @override
  final String routeId;
  final List<String> _storeIds;
  @override
  List<String> get storeIds {
    if (_storeIds is EqualUnmodifiableListView) return _storeIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_storeIds);
  }

  @override
  String toString() {
    return 'RoutesEvent.assignStores(routeId: $routeId, storeIds: $storeIds)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AssignStoresImpl &&
            (identical(other.routeId, routeId) || other.routeId == routeId) &&
            const DeepCollectionEquality().equals(other._storeIds, _storeIds));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, routeId, const DeepCollectionEquality().hash(_storeIds));

  /// Create a copy of RoutesEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AssignStoresImplCopyWith<_$AssignStoresImpl> get copyWith =>
      __$$AssignStoresImplCopyWithImpl<_$AssignStoresImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadRoutes,
    required TResult Function(Routes route) addRoute,
    required TResult Function(Routes route) updateRoute,
    required TResult Function(String id) deleteRoute,
    required TResult Function(String routeId, String driverId) assignDriver,
    required TResult Function(String routeId, List<String> storeIds)
        assignStores,
  }) {
    return assignStores(routeId, storeIds);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadRoutes,
    TResult? Function(Routes route)? addRoute,
    TResult? Function(Routes route)? updateRoute,
    TResult? Function(String id)? deleteRoute,
    TResult? Function(String routeId, String driverId)? assignDriver,
    TResult? Function(String routeId, List<String> storeIds)? assignStores,
  }) {
    return assignStores?.call(routeId, storeIds);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadRoutes,
    TResult Function(Routes route)? addRoute,
    TResult Function(Routes route)? updateRoute,
    TResult Function(String id)? deleteRoute,
    TResult Function(String routeId, String driverId)? assignDriver,
    TResult Function(String routeId, List<String> storeIds)? assignStores,
    required TResult orElse(),
  }) {
    if (assignStores != null) {
      return assignStores(routeId, storeIds);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadRoutes value) loadRoutes,
    required TResult Function(_AddRoute value) addRoute,
    required TResult Function(_UpdateRoute value) updateRoute,
    required TResult Function(_DeleteRoute value) deleteRoute,
    required TResult Function(_AssignDriver value) assignDriver,
    required TResult Function(_AssignStores value) assignStores,
  }) {
    return assignStores(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadRoutes value)? loadRoutes,
    TResult? Function(_AddRoute value)? addRoute,
    TResult? Function(_UpdateRoute value)? updateRoute,
    TResult? Function(_DeleteRoute value)? deleteRoute,
    TResult? Function(_AssignDriver value)? assignDriver,
    TResult? Function(_AssignStores value)? assignStores,
  }) {
    return assignStores?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadRoutes value)? loadRoutes,
    TResult Function(_AddRoute value)? addRoute,
    TResult Function(_UpdateRoute value)? updateRoute,
    TResult Function(_DeleteRoute value)? deleteRoute,
    TResult Function(_AssignDriver value)? assignDriver,
    TResult Function(_AssignStores value)? assignStores,
    required TResult orElse(),
  }) {
    if (assignStores != null) {
      return assignStores(this);
    }
    return orElse();
  }
}

abstract class _AssignStores implements RoutesEvent {
  const factory _AssignStores(
      final String routeId, final List<String> storeIds) = _$AssignStoresImpl;

  String get routeId;
  List<String> get storeIds;

  /// Create a copy of RoutesEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AssignStoresImplCopyWith<_$AssignStoresImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$RoutesState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Routes> routes) loaded,
    required TResult Function(String message) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Routes> routes)? loaded,
    TResult? Function(String message)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Routes> routes)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(Loading value) loading,
    required TResult Function(Loaded value) loaded,
    required TResult Function(Error value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(Loading value)? loading,
    TResult? Function(Loaded value)? loaded,
    TResult? Function(Error value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(Loading value)? loading,
    TResult Function(Loaded value)? loaded,
    TResult Function(Error value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RoutesStateCopyWith<$Res> {
  factory $RoutesStateCopyWith(
          RoutesState value, $Res Function(RoutesState) then) =
      _$RoutesStateCopyWithImpl<$Res, RoutesState>;
}

/// @nodoc
class _$RoutesStateCopyWithImpl<$Res, $Val extends RoutesState>
    implements $RoutesStateCopyWith<$Res> {
  _$RoutesStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of RoutesState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl value, $Res Function(_$InitialImpl) then) =
      __$$InitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$RoutesStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)
      : super(_value, _then);

  /// Create a copy of RoutesState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$InitialImpl implements Initial {
  const _$InitialImpl();

  @override
  String toString() {
    return 'RoutesState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Routes> routes) loaded,
    required TResult Function(String message) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Routes> routes)? loaded,
    TResult? Function(String message)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Routes> routes)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(Loading value) loading,
    required TResult Function(Loaded value) loaded,
    required TResult Function(Error value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(Loading value)? loading,
    TResult? Function(Loaded value)? loaded,
    TResult? Function(Error value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(Loading value)? loading,
    TResult Function(Loaded value)? loaded,
    TResult Function(Error value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class Initial implements RoutesState {
  const factory Initial() = _$InitialImpl;
}

/// @nodoc
abstract class _$$LoadingImplCopyWith<$Res> {
  factory _$$LoadingImplCopyWith(
          _$LoadingImpl value, $Res Function(_$LoadingImpl) then) =
      __$$LoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadingImplCopyWithImpl<$Res>
    extends _$RoutesStateCopyWithImpl<$Res, _$LoadingImpl>
    implements _$$LoadingImplCopyWith<$Res> {
  __$$LoadingImplCopyWithImpl(
      _$LoadingImpl _value, $Res Function(_$LoadingImpl) _then)
      : super(_value, _then);

  /// Create a copy of RoutesState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$LoadingImpl implements Loading {
  const _$LoadingImpl();

  @override
  String toString() {
    return 'RoutesState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Routes> routes) loaded,
    required TResult Function(String message) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Routes> routes)? loaded,
    TResult? Function(String message)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Routes> routes)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(Loading value) loading,
    required TResult Function(Loaded value) loaded,
    required TResult Function(Error value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(Loading value)? loading,
    TResult? Function(Loaded value)? loaded,
    TResult? Function(Error value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(Loading value)? loading,
    TResult Function(Loaded value)? loaded,
    TResult Function(Error value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class Loading implements RoutesState {
  const factory Loading() = _$LoadingImpl;
}

/// @nodoc
abstract class _$$LoadedImplCopyWith<$Res> {
  factory _$$LoadedImplCopyWith(
          _$LoadedImpl value, $Res Function(_$LoadedImpl) then) =
      __$$LoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<Routes> routes});
}

/// @nodoc
class __$$LoadedImplCopyWithImpl<$Res>
    extends _$RoutesStateCopyWithImpl<$Res, _$LoadedImpl>
    implements _$$LoadedImplCopyWith<$Res> {
  __$$LoadedImplCopyWithImpl(
      _$LoadedImpl _value, $Res Function(_$LoadedImpl) _then)
      : super(_value, _then);

  /// Create a copy of RoutesState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? routes = null,
  }) {
    return _then(_$LoadedImpl(
      null == routes
          ? _value._routes
          : routes // ignore: cast_nullable_to_non_nullable
              as List<Routes>,
    ));
  }
}

/// @nodoc

class _$LoadedImpl implements Loaded {
  const _$LoadedImpl(final List<Routes> routes) : _routes = routes;

  final List<Routes> _routes;
  @override
  List<Routes> get routes {
    if (_routes is EqualUnmodifiableListView) return _routes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_routes);
  }

  @override
  String toString() {
    return 'RoutesState.loaded(routes: $routes)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadedImpl &&
            const DeepCollectionEquality().equals(other._routes, _routes));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_routes));

  /// Create a copy of RoutesState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$LoadedImplCopyWith<_$LoadedImpl> get copyWith =>
      __$$LoadedImplCopyWithImpl<_$LoadedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Routes> routes) loaded,
    required TResult Function(String message) error,
  }) {
    return loaded(routes);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Routes> routes)? loaded,
    TResult? Function(String message)? error,
  }) {
    return loaded?.call(routes);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Routes> routes)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(routes);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(Loading value) loading,
    required TResult Function(Loaded value) loaded,
    required TResult Function(Error value) error,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(Loading value)? loading,
    TResult? Function(Loaded value)? loaded,
    TResult? Function(Error value)? error,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(Loading value)? loading,
    TResult Function(Loaded value)? loaded,
    TResult Function(Error value)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class Loaded implements RoutesState {
  const factory Loaded(final List<Routes> routes) = _$LoadedImpl;

  List<Routes> get routes;

  /// Create a copy of RoutesState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$LoadedImplCopyWith<_$LoadedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ErrorImplCopyWith<$Res> {
  factory _$$ErrorImplCopyWith(
          _$ErrorImpl value, $Res Function(_$ErrorImpl) then) =
      __$$ErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$ErrorImplCopyWithImpl<$Res>
    extends _$RoutesStateCopyWithImpl<$Res, _$ErrorImpl>
    implements _$$ErrorImplCopyWith<$Res> {
  __$$ErrorImplCopyWithImpl(
      _$ErrorImpl _value, $Res Function(_$ErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of RoutesState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$ErrorImpl(
      null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ErrorImpl implements Error {
  const _$ErrorImpl(this.message);

  @override
  final String message;

  @override
  String toString() {
    return 'RoutesState.error(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ErrorImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of RoutesState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>
      __$$ErrorImplCopyWithImpl<_$ErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Routes> routes) loaded,
    required TResult Function(String message) error,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Routes> routes)? loaded,
    TResult? Function(String message)? error,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Routes> routes)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(Loading value) loading,
    required TResult Function(Loaded value) loaded,
    required TResult Function(Error value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(Loading value)? loading,
    TResult? Function(Loaded value)? loaded,
    TResult? Function(Error value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(Loading value)? loading,
    TResult Function(Loaded value)? loaded,
    TResult Function(Error value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class Error implements RoutesState {
  const factory Error(final String message) = _$ErrorImpl;

  String get message;

  /// Create a copy of RoutesState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
